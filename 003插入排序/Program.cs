using System;

namespace _003插入排序
{
    internal class Program
    {
        static void Main(string[] args)
        {
            int[] nums = { 2, 5, 1, 6, 8, 12, 81, 23 };
            InsertionSort(nums);
            foreach (var item in nums)
            {
                System.Console.WriteLine(item);
            }

            #region 插入排序基本原理
            //8 7 1 5 4 2 6 3 9 1
            //两个区域
            //排序区
            //未排序区
            //用一个索引值做分水岭

            //未排序区元素与排序区元素比较
            //插入到合适位置
            //直到未排序区清空
            #endregion

            #region 知识点二代码实现
            //升序排序
            int[] arr = new int[] { 8, 7, 1, 5, 4, 2, 6, 3, 9 };
            //前提规则
            //排序开始前
            //首先认为第一个元素在排序区中
            //其它所有元素在未排序区中


            //排序开始后
            //每次将未排序区第一个元素取出用于和
            //排序区中元素比较（从后往前）
            //满足条件（较大或者较小）
            //则排序区中元素往后移动一个位置。

            //注意：
            //所有数字都在一个数组中
            //所谓的两个区域是一个分水岭索引

            //第一步
            //能取出未排序区的所有元素进行比较
            //i=1的原因：默认第一个元素就在排序区
            for (int i = 1; i < arr.Length; i++)
            {
                //第二步
                //每一轮
                //1.取出排序区的最后一个元素素引
                int sortIndex = i - 1;
                //2.取出未排序区的第一个元素
                int current = arr[i];

                //第三步
                //在未排序区进行比较
                //移动位置
                //确定插入索引

                //循环停止条件
                //1.发现排序区中所有元素都比较完
                //2.发现排序区中的元素不满足条件
                while (sortIndex >= 0 && arr[sortIndex] > current)
                {
                    //排序区中的元素往后移动一个位置
                    arr[sortIndex + 1] = arr[sortIndex];
                    //继续向前比较，是从排序区后面开始比较的
                    --sortIndex;
                }
                //确定位置，最终的插入数字
                arr[sortIndex + 1] = current;
            }

            for (int i = 0; i < arr.Length; i++)
            {
                Console.WriteLine(arr[i]);
            }
            #endregion

            #region 总结
            //为什么有两层循环
            //第一层循环：一次取出未排序区的元素进行排序
            //第二层循环：找到想要插入的位置

            //为什么第一层循环从1开始遍历
            //插入排序的关键是分两个区域
            //已排序区和未排序区
            //默认第一个元素在已排序区

            //为什么使用while循环
            //满足条件才比较
            //否则证明插入位置已确定
            //不需要继续循环

            //为什么可以直接往后移位置
            //每轮未排序数已记录
            //最后一个位置不怕丢

            //为什么确定位置后，是放在sortIndex+1的位置
            //当循环停止时，插入位置应该是停止循环的索引加1处

            //基本原理
            //两个区域
            //用索引1值来区分
            //未排序区与排序区
            //元素不停比较
            //找到合适位置
            //插入当前元素

            //套路写法
            //两层循环1
            //一层获取未排序区元素
            //一层找到合适插入位置

            //注意事项
            //默认开头已排序
            //第二层循环外插入

            #endregion
        }

        #region 插入排序
        /*
        核心思想是逐个将未排序元素插入已排序部分，从左至右逐步构建有序序列。
        步骤：
        1.从第二个元素开始，将其视为当前元素，存储在变量current中。
        2.从当前元素开始，与已排序的元素逐一比较，如果已排序元素大于current，则将已排序元素右移一个位置。
        3.继续向前比较，直到找到current的正确位置，然后将其插入到这个位置。
        4.重复上述步骤，逐个插入未排序元素，直到整个数组有序。

        特点：
        1.简单理解和实现
        2.稳定性：它是一种稳定的排序算法，即相等元素的相对位置不会改变，有利于保持相等元素的相对次序。

        缺点：
        1.低效性：平均和最坏情况时间复杂度为O(n^2)
        2.不适用于逆序数据
        3.缺乏适应性：插入排序不适应数据的初始状态。它无论数据是否部分有序，都需要执行相同数量的比较和移动操作。这在某些情况下是不必要的，因为有些数据集可能已经接近排序状态。
        4.稳定性带来的额外开销：虽然稳定性是插入排序的一个优点，但这也意味着它需要在比较相等元素时执行额外的操作，这可能会增加执行时间。
         */
        #endregion

        public static void InsertionSort(int[] array)
        {
            for (int i = 1; i < array.Length; i++)
            {
                int current = array[i];//记录待排序的值，后续插入到已排序部分
                int j = i - 1;

                // 将当前元素插入到已排序部分的正确位置
                while (j >= 0 && array[j] > current)
                {
                    //移动已排序区的元素
                    array[j + 1] = array[j];
                    --j;
                }
                array[j + 1] = current;
            }
        }
    }
}
